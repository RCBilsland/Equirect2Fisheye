uniform float4x4 ViewProj;
uniform texture2d image;
uniform float fov;
uniform float pan;
uniform float tilt;
uniform float yaw;
uniform float aspect;
uniform float outside_alpha;

sampler_state textureSampler {
    Filter    = Linear;
    AddressU  = Clamp;
    AddressV  = Clamp;
};

struct VertData {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = v_in.uv;
    return vert_out;
}

float2 fisheye_transform(float2 uv, float fov_rad, float pan_rad, float tilt_rad, float yaw_rad, float aspect_ratio)
{
    // Convert UV coordinates to normalized coordinates (-1 to 1)
    float2 coord = (uv - 0.5) * 2.0;
    
    // Apply aspect ratio correction
    coord.x *= aspect_ratio;
    
    // Calculate distance from center
    float r = length(coord);
    
    // Check if pixel is outside fisheye circle
    if (r > 1.0) {
        return float2(-1.0, -1.0); // Return invalid coordinates for outside pixels
    }
    
    // Convert to fisheye coordinates
    float alpha = r * fov_rad * 0.5;
    float theta = atan2(coord.y, coord.x);
    
    // Apply rotations
    float3 P = float3(
        sin(alpha) * cos(theta),
        sin(alpha) * sin(theta),
        cos(alpha)
    );
    
    // Apply pan (Y rotation)
    float cos_pan = cos(pan_rad);
    float sin_pan = sin(pan_rad);
    P = float3(
        P.x * cos_pan + P.z * sin_pan,
        P.y,
        P.z * cos_pan - P.x * sin_pan
    );
    
    // Apply tilt (X rotation)
    float cos_tilt = cos(tilt_rad);
    float sin_tilt = sin(tilt_rad);
    P = float3(
        P.x,
        P.y * cos_tilt - P.z * sin_tilt,
        P.y * sin_tilt + P.z * cos_tilt
    );
    
    // Apply yaw (Z rotation)
    float cos_yaw = cos(yaw_rad);
    float sin_yaw = sin(yaw_rad);
    P = float3(
        P.x * cos_yaw - P.y * sin_yaw,
        P.x * sin_yaw + P.y * cos_yaw,
        P.z
    );
    
    // Convert back to equirectangular UV coordinates
    float latitude = asin(P.y / length(P));
    float longitude = atan2(P.x, P.z);
    
    // Convert to UV coordinates (0 to 1)
    float u = (longitude / (2.0 * 3.14159265359)) + 0.5;
    float v = 1.0 - (latitude / 3.14159265359 + 0.5);
    
    return float2(u, v);
}

float4 PSDefault(VertData v_in) : TARGET
{
    float2 uv = v_in.uv;
    
    // Convert degrees to radians
    float fov_rad = fov * 3.14159265359 / 180.0;
    float pan_rad = pan * 3.14159265359 / 180.0;
    float tilt_rad = tilt * 3.14159265359 / 180.0;
    float yaw_rad = yaw * 3.14159265359 / 180.0;
    
    // Apply fisheye transformation
    float2 transformed_uv = fisheye_transform(uv, fov_rad, pan_rad, tilt_rad, yaw_rad, aspect);
    
    // Check if pixel is outside fisheye circle
    if (transformed_uv.x < 0.0 || transformed_uv.x > 1.0 || transformed_uv.y < 0.0 || transformed_uv.y > 1.0) {
        return float4(0.0, 0.0, 0.0, outside_alpha);
    }
    
    // Sample the input texture
    float4 color = image.Sample(textureSampler, transformed_uv);
    
    return color;
}

technique Draw
{
    pass
    {
        vertex_shader = VSDefault(v_in);
        pixel_shader  = PSDefault(v_in);
    }
}
